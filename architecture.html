<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group 4 Cohort 4 Assessment 1</title>
    <link rel="stylesheet" href="style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chicle&display=swap" rel="stylesheet">
</head>

<body>
    <div class = "Navigation">
        <div class = "image">
            <img src = "logo.png" style = "height: 180px;">
        </div>
        <div class = "Title">
            <h1>Engineering 1: Assessment 1</h1>
            <h2>Cohort 4 Group 4: FOUR</h2>
            <h3>by Daniel Bassey, Gracie Dudgeon, Henry Fields, Nissy Katta, Oscar MacDonald, Yakup Ozturk and Hannah Pugh </h3>
        </div>
    </div>

    <div class = "Deliverables">
        <div class = "Deliverables-Links">
            <ul>
                <li> <a href = "/index.html"> Requirements </a> </li>
                <li> <a href = "/architecture.html" > Architecture </a> </li>
                <li> <a href = "/Method selection and planning.html" > Method selection and planning </a> </li>
                <li> <a href = "/Risk assessment and mitigation.html" > Risk assessment and mitigation  </a> </li>
                <li> <a href = "/Implementation.html" > Implementation </a> </li>
                <li> <a href = "FOUR-Game-1.0.0(3).jar" target = "_blank"> Executable JAR </a> </li>
                <li> <a href = "https://github.com/FOUR-York/FOUR-Game" target="_blank"> Version control repository </a> </li>
                <li> <a href = "https://github.com/dlb2323/dlb2323.github.io" target="_blank"> Website Repository </a> </li>
            </ul>
        </div>
    
        <div class = "Deliverables-Viewer">
            <div id = "Architecture">
                <h1 style = "text-align: center;">Architecture</h1>
                <p>Link to PDF document: <a href = "https://drive.google.com/file/d/15r9u1WoR6ziUFUe8ykXotQtSEkBBrWKM/view?usp=drive_link" target = "_blank">here</a></p>
                <div class = "Diagram-Links">
                    <a href = "#UML Class Diagram">Final UML Class Diagram</a>
                    <a href = "#Initial Prototype">Initial Prototypes</a>
                    <a href = "#Second Design Phase">State Machine Diagrams</a>
                    
                </div>

                <h2>Introduction to our Diagrams</h2>

                <p>To describe how we plan to implement different functions of the game, we have chosen to use UML diagrams. Structural Diagrams will be used to visualize core entities, their features, and relationships - covering the static portion of the project. In contrast, Behavioural Diagrams include sequence diagrams covering how components interact with each other. We will be creating Structural Class diagrams and State Machine diagrams, for each of the main UML diagram categories. We chose to use these specific diagrams as they are the most commonly used diagrams, meaning they will be widely understood and have plenty of resources available.
                <br><br>
                For an Architecture Pattern, we will be using an Entity-Component-Systems Diagram. This is a favoured method in video game development, as it facilitates code reusability, allowing us to save time in the production phase of this project. This is important considering the short amount of time we have. It is an appropriate use case as a lot of the built-in LibGDX classes have to be implemented using composition, such as <i>TextureRegion</i>, <i>&lt;Animation<TextureRegion>&gt;</i> and <i>OrthographicCamera</i>. We will be using Inheritance for some of the Entities, for example <i>Player</i> and <i>Enemy</i> inherits from <i>Entity</i>. This stops code repetition as the parent class will have a method defined, one example in our code is the fact <i>Entity</i> has the <i>draw</i> method (placing the Entities onto the screen) defined, meaning it doesn’t have to be repeated in the <i>Enemy</i> and <i>Player</i> class. 
                <br><br>
                Find the final UML Class diagram <a href = "#UML Class Diagram">here</a>.</p>
                <p>To create these Structural and Behavioral diagrams, we have decided to use <a href = "https://app.diagrams.net/">Draw.io</a>. It is a free, web-based platform that requires no download; which has the functionalities we require. Other options available were either too sophisticated for our needs or required additional external software.</p>
                <h2>Our thoughts when designing the Diagrams</h2>
                <p>We began by considering the main objects of the game: the Player and the Enemies. These are the principle moving parts of the game. They will share some common methods (such as <i>collision</i>, <i>kill</i> and <i>move</i>) and attributes (such as <i>texture</i>, <i>position</i>, <i>speed</i>). Therefore, we have decided to put them all in the same parent class, reducing code repetition. There will be more in common between the Player and Enemies, than between them and a Projectile. For example, a Projectile does not have HP. So, we have designed an abstract sub-class that contains these extra functionalities, which will be the parent class of the <i>Player</i> and <i>Enemy</i> classes, named <i>LivingThings</i>. 
                <br><br>
                Over the course of this project, we had three interim design phases, creating diagrams for our thoughts in the beginning, middle and end. </p>
                <h2>First Design Phase</h2>
                <p>The Initial UML Class Diagrams can be found <a href = "#Initial Prototype">here</a>, they are in order of creation. </p>
                <h2 id = "Initial Prototype"> Initial Prototype </h2>
                <table>
                    <tr>
                            <th>Key</th>
                            <th>Definition</th>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>Method</td>
                    </tr>
                    <tr>
                        <td>IM</td>
                        <td>Implemented Method</td>
                    </tr>
                    <tr>
                        <td>UM</td>
                        <td>Unimplemented Method</td>
                    </tr>
                    <tr>
                        <td>A</td>
                        <td>Attribute</td>
                    </tr>
                </table>

                <img src = "Initial Prototype.png" style = "padding: 20px; border: 1px solid black; margin-right: 20px;">
                <img src = "Initial Prototype 2.png" style = "padding: 20px; border: 1px solid black; margin-right: 20px;">
                <p>On our first approach, we prioritised the <i>Entity</i> Class, and the two derived classes <i>Player</i> and <i>Enemy</i>. On the final diagram, we chose to include <i>Projectiles</i> as a class, inheriting from <i>Entity</i> - this meant we had to include a new derived class to <i>Entity</i>, <i>LivingThings</i>. This will be the new parent class to <i>Player</i> and <i>Enemy</i>, a decision made because they share attributes (for example <i>dmg</i> and <i>hp</i>) and methods (such as <i>Move</i> and <i>Attack</i>).</p>
                <br><br>
                Our initial thought process was that the 3 classes (<i>Enemy</i>, <i>Player</i> and <i>Projectile</i>) will share a number of attributes and functions. For example, the <i>collision</i> method, which is implemented in the superclass <i>Entity</i>, will be used by all three classes. All entities will have the same collision detection method, meaning there’s no need to have duplicated methods.
                <br><br>
                This is the final UML Diagram we made during this phase:</p>

                <img src = "Initial Prototype 3.png" style = "padding: 20px; border: 1px solid black;">
                
                <h2 id = "Second Design Phase">Second Design Phase</h2>
                <p>Our first task during this phase was to create a State Machine Diagram. This Behavioural Diagram allowed us to abstract the three main derived classes we were going to create. Detailing no attributes or methods, this diagram would help us understand the core purpose and roles a class would need - allowing us to focus on how we would implement later. We have replaced <i>Projectile</i> with <i>Item</i> in this diagram. You can find the Diagrams on the website <a href = "#Second Design Phase">here</a>.
                <br><br>
                <img src = "Enemy_ State Machine Diagram.drawio.png" style = "padding: 20px; border: 1px solid black;">
                <img src = "Item_ State Machine Diagram.drawio.png" style = "padding: 20px; border: 1px solid black;">
                <img src = "Player_ State Machine Diagram.drawio.png" style = "padding: 20px; border: 1px solid black;">
                <br><br>
                The main focus in this design phase was to further modularisation of the <i>Entity</i> class and its functionality. As mentioned in the State Machine Diagrams, we have replaced the <i>Projectiles</i> class with <i>FloorItem</i>. Our plan is that any item in the game will be found on the floor, waiting to be picked up by the player. </p>

                <img src = "Entity Class 2.png">
                <h2>Final Design Phase</h2>
                <p>During the final stretch of the project, we thought it important to create an Entity-Component-System Diagram to show how our three Entities (<i>Player</i>, <i>Enemy</i>, and <i>Item</i>) will work with the LibGDX library. </p>

                <img src = "ECS Final Diagram(1).png">
                <p>
                The entities at the top (<i>Entity</i>, <i>Player</i>, <i>LivingThing</i>, <i>Enemy</i> and <i>Item</i>) are all classes that we have implemented ourselves. All of the Components at the bottom are given from the LibGDX library, and have been implemented for us to use. 
                <br><br>
                The <i>Texture</i> Component allows the <i>Entity</i> to have an appearance, using one of our created assets. The <i>Sprite</i> Component holds the information about the <i>Entity</i>, the texture, source coordinates and source size. The <i>TextureRegion</i> Component is used to hold the animation frames, and the <i>Animation</i> component is what helps animate the Entities on screen. 
                </p>

                <img id = "UML Class Diagram" src = "UML Class Diagram.png">

                <p>
                Our final UML Class diagram includes specific methods and attributes that aid the classes. We used abstraction to not over-complicate the design process and avoid making specific implementation decisions. For example, as per our <i>FR_PLAYER_NAVIGATION</i> requirement, the <i>Player</i> being able to move is an important part of the game. Prior to this design, we didn’t include the Animation frames, allowing us to change how the Player will move. This requirement is fulfilled with the move method in the <i>Player</i> class.
                <br><br>
                The Combat Requirement <i>FR_COMBAT_MECHANISM</i> is fulfilled using a variety of methods. The <i>Enemy</i> class has a <i>IsPlayerInSight</i> method that alerts it when the <i>Player</i> is in a certain range, predetermined as an attribute in the <i>Enemy</i> class. Once the <i>Player</i> is in range, the <i>Enemy</i> class uses the functions chase and swing to make sure the <i>Player</i> is in range of attacking by following them and once they are in range, the <i>Enemy</i> deals damage to the <i>Player</i>. As per our <i>UR_GAMEOVER</i> requirement, the <i>Player</i> will never die but instead be “down” meaning that the health regenerates and the <i>Enemy</i> will no longer see that the <i>Player</i> is in range so it will start patrolling again. This means that the Player will have to wait for their health to be full again, which will take away from their 5 minute limit.
                </p>

            </div>
        </div>
    </div>
</body>

</html>