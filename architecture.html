<!DOCTYPE html>

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Group 4 Cohort 4 Assessment 1</title>
    <link rel="stylesheet" href="style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Chicle&display=swap" rel="stylesheet">
</head>

<body>
    <div class = "Navigation">
        <div class = "image">
            <img src = "logo.png" style = "height: 180px;">
        </div>
        <div class = "Title">
            <h1>Engineering 1: Assessment 1</h1>
            <h2>Cohort 4 Group 4: FOUR</h2>
            <h3>by Daniel Bassey, Gracie Dudgeon, Henry Fields, Nissy Katta, Oscar MacDonald, Yakup Ozturk and Hannah Pugh </h3>
        </div>
    </div>

    <div class = "Deliverables">
        <div class = "Deliverables-Links">
            <ul>
                <li> <a href = "/index.html"> Requirements </a> </li>
                <li> <a href = "/architecture.html" > Architecture </a> </li>
                <li> <a href = "/Method selection and planning.html" > Method selection and planning </a> </li>
                <li> <a href = "/Risk assessment and mitigation.html" > Risk assessment and mitigation  </a> </li>
                <li> <a href = "/Implementation.html" > Implementation </a> </li>
                <li> <a target="_blank"> Executable JAR </a> </li>
                <li> <a href = "https://github.com/FOUR-York" target="_blank"> Version control repository </a> </li>
            </ul>
        </div>
    
        <div class = "Deliverables-Viewer">
            <div id = "Architecture">
                <h1 style = "text-align: center;">Architecture</h1>
                <p>Link to PDF document: <a href = "https://drive.google.com/file/d/1moiKZ5c5r-OmcxwkzLNF9TErWI2zm4tE/view?usp=sharing" target = "_blank">here</a></p>
                <div class = "Diagram-Links">
                    <a href = "#UML Class Diagram">Final UML Class Diagram</a>
                    <a href = "#Initial Prototype">Initial Prototypes</a>
                    <a href = "#Second Design Phase">State Machine Diagrams</a>
                    
                </div>

                <h2>Introduction to our Diagrams</h2>

                <p>To describe how we plan to implement different functions of the game, we have chosen to use UML diagrams. Structural Diagrams will visualize core entities, their features, and relationships - covering the static portion of the project. In contrast, Behavioural Diagrams include sequence diagrams covering how components interact with each other. We will be creating Structural Class diagrams and State Machine diagrams, for each of the main UML diagram categories. We chose to use these specific diagrams as they are the most commonly used diagrams, meaning they will be widely understood and have plenty of resources available.
                <br><br>
                For an Architecture Pattern, we will be using an Entity-Component-Systems Diagram. This is a favoured method in video game development, as it facilitates code reusability, allowing us to save time in the production phase of this project. This is important considering the short amount of time we have. It is an appropriate use case as a lot of the built-in LibGDX classes have to be implemented using composition, such as TextureRegion, Animation<TextureRegion> and OrthographicCamera. We will be using Inheritance for some of the Entities, for example Player and Enemy inherits from Entity. This stops code repetition as the parent class will have a method defined, one example in our code is the fact Entity has the draw method (placing the Entities onto the screen) defined, meaning it doesn’t have to be repeated in the Enemy and Player class. 
                <br><br>
                Find the final UML Class diagram <a href = "#UML Class Diagram">here</a>.</p>
                <p>To create these Structural and Behavioral diagrams, we have decided to use <a href = "https://app.diagrams.net/">Draw.io</a>. It is a free, web-based platform that requires no download; which has the functionalities we require. Other options available were either too sophisticated for our needs or required additional external software.</p>
                <h2>Our thoughts when designing the Diagrams</h2>
                <p>We began by considering the main objects of the game: the Player and the Enemies. These are the principle moving parts of the game. They will share some common methods (such as collision, kill and move) and attributes (such as texture, position, speed). Therefore, we have decided to put them all in the same parent class, reducing code repetition. There will be more in common between the Player and Enemies, than between them and a Projectile. For example, a Projectile does not have HP. So, we have designed an abstract sub-class that contains these extra functionalities, which will be the parent class of the Player and Enemy classes, named LivingThings. 
                <br><br>
                Over the course of this project, we had three interim design phases, creating diagrams for our thoughts in the beginning, middle and end. </p>
                <h2>First Design Phase</h2>
                <p>The Initial UML Class Diagrams can be found <a href = "#Initial Prototype">here</a>, they are in order of creation. </p>
                <h2 id = "Initial Prototype"> Initial Prototype </h2>
                <table>
                    <tr>
                            <th>Key</th>
                            <th>Definition</th>
                    </tr>
                    <tr>
                        <td>M</td>
                        <td>Method</td>
                    </tr>
                    <tr>
                        <td>IM</td>
                        <td>Implemented Method</td>
                    </tr>
                    <tr>
                        <td>UM</td>
                        <td>Unimplemented Method</td>
                    </tr>
                    <tr>
                        <td>A</td>
                        <td>Attribute</td>
                    </tr>
                </table>

                <img src = "Initial Prototype.png" style = "padding: 20px; border: 1px solid black; margin-right: 20px;">
                <img src = "Initial Prototype 2.png" style = "padding: 20px; border: 1px solid black; margin-right: 20px;">
                <p>On our first approach, we prioritised the Entity Class, and the two derived classes Player and Enemy. On the final diagram, we chose to include Projectiles as a class, inheriting from Entity - this meant we had to include a new derived class to Entity, LivingThings. This will be the new parent class to Player and Enemy, a decision made because they share attributes (for example dmg and hp) and methods (such as Move and Attack).</p>
                <br><br>
                Our initial thought process was that the 3 classes (Enemy, Player and Projectile) will share a number of attributes and functions. For example, the collision method, which is implemented in the superclass Entity, will be used by all three classes. All entities will have the same collision detection method, meaning there’s no need to have duplicated methods.
                <br><br>
                This is the final UML Diagram we made during this phase:</p>

                <img src = "Initial Prototype 3.png" style = "padding: 20px; border: 1px solid black;">
                
                <h2 id = "Second Design Phase">Second Design Phase</h2>
                <p>Our first task during this phase was to create a State Machine Diagram. This Behavioural Diagram allowed us to abstract the three main derived classes we were going to create. Detailing no attributes or methods, this diagram would help us understand the core purpose and roles a class would need - allowing us to focus on how we would implement later. We have replaced Projectile with Item in this diagram. You can find the Diagrams on the website <a href = "#Second Design Phase">here</a>.
                <br><br>
                <img src = "Enemy_ State Machine Diagram.drawio.png" style = "padding: 20px; border: 1px solid black;">
                <img src = "Item_ State Machine Diagram.drawio.png" style = "padding: 20px; border: 1px solid black;">
                <img src = "Player_ State Machine Diagram.drawio.png" style = "padding: 20px; border: 1px solid black;">
                <br><br>
                The main focus in this design phase was to further modularisation of the Entity class and its functionality. As mentioned in the State Machine Diagrams, we have replaced the Projectiles class with FloorItem. Our plan is that any item in the game will be found on the floor, waiting to be picked up by the player. </p>

                <img src = "Entity Class 2.png">
                <h2>Final Design Phase</h2>
                <p>During the final stretch of the project, we thought it important to create an Entity-Component-System Diagram to show how our three Entities (Player, Enemy, and Item) will work with the LibGDX library. </p>

                <img src = "ECS Final Diagram(1).png">
                <p>
                The entities at the top (Entity, Player, LivingThing, Enemy and Item) are all classes that we have implemented ourselves. All of the Components at the bottom are given from the LibGDX library, and have been implemented for us to use. 
                <br><br>
                The Texture Component allows the Entity to have an appearance, using one of our created assets. The Sprite Component holds the information about the Entity, the texture, source coordinates and source size. The TextureRegion Component is used to hold the animation frames, and the Animation component is what helps animate the Entities on screen. 
                </p>

                <img id = "UML Class Diagram" src = "UML Class Diagram.png">

                <p>
                Our final UML Class diagram includes specific methods and attributes that aid the classes. We used abstraction to not over-complicate the design process and avoid making specific implementation decisions. For example, as per our FR_PLAYER_NAVIGATION requirement, the Player being able to move is an important part of the game. Prior to this design, we didn’t include the Animation frames, allowing us to change how the Player will move. This requirement is fulfilled with the move method in the Player class.
                <br><br>
                The Combat Requirement FR_COMBAT_MECHANISM is fulfilled using a variety of methods. The Enemy class has a IsPlayerInSight method that alerts it when the Player is in a certain range, predetermined as an attribute in the Enemy class. Once the Player is in range, the Enemy class uses the functions chase and swing to make sure the Player is in range of attacking by following them and once they are in range, the Enemy deals damage to the Player. As per our UR_GAMEOVER requirement, the Player will never die but instead be “down” meaning that the health regenerates and the Enemy will no longer see that the Player is in range so it will start patrolling again. This means that the Player will have to wait for their health to be full again, which will take away from their 5 minute limit.
                </p>

            </div>
        </div>
    </div>
</body>

</html>